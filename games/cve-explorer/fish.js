var is_running = false;
let img;
let animationId;

function button_click() {
  var bar = document.getElementById("bar");
  var bodyRect = document.body.getBoundingClientRect(),
    barRect = bar.getBoundingClientRect();
  if (is_running) {
    var p = interruptAnimation(img);
    var g = barRect.left;
    var l = 340;
    var res = (((abso(p - g - l / 2) + l / 2) / l) * 100 - 50) * 2;
    show_res(res);
    return;
  }
  console.log("click");
  img = document.createElement("img");
  img.src = "assets/cursor_scaled.png";
  img.style.position = "absolute";
  img.style.left = barRect.left + "px";
  img.style.top = barRect.top - 12 + "px";
  // This next line will just add it to the <body> tag
  document.body.appendChild(img);
  is_running = true;
  move_cursor(img, 340, 1500);
}

function move_cursor(img, distance, duration = 500) {
  let start = null;
  const initialLeft = parseInt(getComputedStyle(img).left) || 0;

  function animate(timestamp) {
    if (!start) start = timestamp;

    const progress = Math.min((timestamp - start) / duration, 1);

    // Move forward first half, backward second half
    const forward = progress <= 0.5;
    const pct = forward ? progress * 2 : (1 - progress) * 2;

    const newX = initialLeft + pct * distance;
    img.style.left = newX + "px";

    if (progress < 1) {
      animationId = requestAnimationFrame(animate);
    } else {
      document.body.removeChild(img);
      is_running = false;
    }
  }

  animationId = requestAnimationFrame(animate);
}

function interruptAnimation(img) {
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }

  const currentLeft = parseFloat(getComputedStyle(img).left);
  return currentLeft;
}

function abso(a) {
  if (a < 0) {
    return -a;
  } else {
    return a;
  }
}

function open_modal() {
  var modal = document.getElementById("myModal");
  modal.style.display = "block";
}

function close_modal() {
  location.reload();
}

async function show_res(res) {
  var level_p = document.getElementById("level_p");
  var fish_i = document.getElementById("fish_i");
  if (res < 20) {
    level_p.innerText = "This is a super duper mega rare fish... uh no, a CVE";
    fish_i.src = "assets/fish1.webp";
    completeGame('cve');
  } else if (res < 40) {
    level_p.innerText = "This is an impressive fish, good catch!";
    fish_i.src = "assets/fish2.webp";
  } else if (res < 60) {
    level_p.innerText =
      "This is a nice looking fish, I'll store it in my fish cave";
    fish_i.src = "assets/fish3.webp";
  } else if (res < 80) {
    level_p.innerText = "Meh... This fish looks like a fish";
    fish_i.src = "assets/fish4.webp";
  } else {
    level_p.innerText = "This is straight up trash... get gud";
    fish_i.src = "assets/fish5.webp";
  }

  try {
    // Fetch the latest CVEs from CIRCL
    const response = await fetch(
      "https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=20&startIndex=" +
        getRandomInt(320200),
    );
    const cves = await response.json();
    console.log(cves);
    if (!cves.resultsPerPage) {
      console.log("No CVEs found.");
      return;
    }

    // Pick a random CVE
    const randomCVE =
      cves.vulnerabilities[Math.floor(Math.random() * cves.resultsPerPage)].cve;

    // Extract essential info
    document.getElementById("cve_id").innerText = randomCVE.id;
    document.getElementById("cve_sum").innerText =
      randomCVE.descriptions[0].value;
    document.getElementById("cve_date").innerText = randomCVE.published;
    document.getElementById("cve_link").innerText =
      "https://nvd.nist.gov/vuln/detail/" + randomCVE.id;
    document.getElementById("cve_link").href =
      "https://nvd.nist.gov/vuln/detail/" + randomCVE.id;
  } catch (error) {
    console.error("Error fetching CVEs:", error);
  }
  open_modal();
}

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

async function button_search() {
  try {
    // Fetch the latest CVEs from CIRCL
    const response = await fetch(
      "https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=" +
        document.getElementById("search_box").value,
    );
    const cves = await response.json();
    console.log(cves);
    if (!cves.resultsPerPage) {
      console.log("No CVEs found.");
      return;
    }

    // Pick a random CVE
    const randomCVE =
      cves.vulnerabilities[Math.floor(Math.random() * cves.resultsPerPage)].cve;

    // Extract essential info
    document.getElementById("cve_id").innerText = randomCVE.id;
    document.getElementById("cve_sum").innerText =
      randomCVE.descriptions[0].value;
    document.getElementById("cve_date").innerText = randomCVE.published;
    document.getElementById("cve_link").innerText =
      "https://nvd.nist.gov/vuln/detail/" + randomCVE.id;
    document.getElementById("cve_link").href =
      "https://nvd.nist.gov/vuln/detail/" + randomCVE.id;
  } catch (error) {
    console.error("Error fetching CVEs:", error);
  }
}

// Initialize background music when page loads
document.addEventListener('DOMContentLoaded', () => {
  initGameMusic('music.mp3', 'background-music');
});

